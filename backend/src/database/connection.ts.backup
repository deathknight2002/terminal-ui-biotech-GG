import { config } from '../config/environment.js';
import { logger } from '../utils/logger.js';
import { mockDb } from './mock-service.js';

// Simplified connection service for development
export let isConnected = false;

export async function connectDatabases(): Promise<void> {
  try {
    // For development, we'll use the mock database service
    logger.info('üöÄ Starting Biotech Terminal Backend in Development Mode');
    logger.info('üìä Using sophisticated mock data service');
    
    // Simulate connection delay
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Mark as connected
    isConnected = true;
    
    logger.info('‚úÖ Mock database service initialized');
    logger.info('üß¨ Biotech data ready: Aurora Fund, Clinical Trials, Financial Models');
    logger.info('üìà Available endpoints: /dashboard, /trials, /financial-models, /pipeline');

  } catch (error) {
    logger.error('‚ùå Mock database initialization failed:', error);
    throw error;
  }
}

export async function disconnectDatabases(): Promise<void> {
  try {
    isConnected = false;
    logger.info('üîå Mock database service disconnected');
  } catch (error) {
    logger.error('‚ùå Error disconnecting mock database:', error);
  }
}

// Export mock database service for use in routes
export { mockDb };

// Health check function
export async function checkDatabaseHealth(): Promise<boolean> {
  return isConnected;
    // Test QuestDB
    const questResult = await questDbClient.query('SELECT NOW() as timestamp');
    logger.info(`üìä QuestDB test: ${questResult.rows[0].timestamp}`);

    // Test TimescaleDB
    const tsResult = await timescaleClient.query('SELECT NOW() as timestamp');
    logger.info(`üìä TimescaleDB test: ${tsResult.rows[0].timestamp}`);

    // Test Redis
    await redisClient.set('health_check', Date.now().toString());
    const redisResult = await redisClient.get('health_check');
    logger.info(`üìä Redis test: ${redisResult}`);

  } catch (error) {
    logger.error('‚ùå Database health check failed:', error);
    throw error;
  }
}

export async function closeDatabases(): Promise<void> {
  try {
    await postgresClient?.end();
    await questDbClient?.end();
    await timescaleClient?.end();
    await redisClient?.quit();
    logger.info('‚úÖ All database connections closed');
  } catch (error) {
    logger.error('‚ùå Error closing database connections:', error);
  }
}

// Database health check function
export async function checkDatabaseHealth(): Promise<{
  postgres: boolean;
  questdb: boolean;
  timescale: boolean;
  redis: boolean;
}> {
  const health = {
    postgres: false,
    questdb: false,
    timescale: false,
    redis: false,
  };

  try {
    await postgresClient.query('SELECT 1');
    health.postgres = true;
  } catch (error) {
    logger.warn('PostgreSQL health check failed:', error);
  }

  try {
    await questDbClient.query('SELECT 1');
    health.questdb = true;
  } catch (error) {
    logger.warn('QuestDB health check failed:', error);
  }

  try {
    await timescaleClient.query('SELECT 1');
    health.timescale = true;
  } catch (error) {
    logger.warn('TimescaleDB health check failed:', error);
  }

  try {
    await redisClient.ping();
    health.redis = true;
  } catch (error) {
    logger.warn('Redis health check failed:', error);
  }

  return health;
}